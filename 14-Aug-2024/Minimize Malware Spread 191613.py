# Problem: Minimize Malware Spread - https://leetcode.com/problems/minimize-malware-spread/

class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px == py:
            return
        if self.rank[px] < self.rank[py]:
            self.parent[px] = py
        elif self.rank[px] > self.rank[py]:
            self.parent[py] = px
        else:
            self.parent[py] = px
            self.rank[px] += 1


class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
    
        def count_infected(excluded_node):
            uf = UnionFind(n)
            
            for i in range(n):
                for j in range(i+1, n):
                    if graph[i][j] == 1:
                        uf.union(i, j)
            
            infected_components = set()
            for node in initial:
                if node != excluded_node:
                    infected_components.add(uf.find(node))

            infected_count = 0
            for i in range(n):
                if uf.find(i) in infected_components:
                    infected_count += 1
            
            return infected_count
        
        min_infected = float('inf')
        min_node = -1
        
        for node in sorted(initial):
            infected = count_infected(node)
            if infected < min_infected:
                min_infected = infected
                min_node = node
        
        return min_node